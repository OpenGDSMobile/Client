<!DOCTYPE html>
<html lang="en" class="yui-overrride">
<head>
    <meta charset="utf-8">
    <title>js/openGDSMobile/Sortable.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600,700' rel='stylesheet' type='text/css'>
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            <h1 class="blue-main-title"></h1>
        </div>
        <div class="yui3-u-1-4 version project-version">
            API Docs for:
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>

                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>

                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/OGDSM.html">OGDSM</a></li>
                                <li><a href="../classes/OGDSM.attributeTable.html">OGDSM.attributeTable</a></li>
                                <li><a href="../classes/OGDSM.eGovFramUI.html">OGDSM.eGovFramUI</a></li>
                                <li><a href="../classes/OGDSM.externalConnection.html">OGDSM.externalConnection</a></li>
                                <li><a href="../classes/OGDSM.mapLayerList.html">OGDSM.mapLayerList</a></li>
                                <li><a href="../classes/OGDSM.visualization.html">OGDSM.visualization</a></li>
                                <li><a href="../classes/Sortable.html">Sortable</a></li>
                            </ul>

                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/OGDSM.jsontoArray.html">OGDSM.jsontoArray</a></li>
                                <li><a href="../modules/OGDSM.namespace.html">OGDSM.namespace</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>

                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>

                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>

                </div>

            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: js/openGDSMobile/Sortable.js</h1>

                        <div class="file">
                            <pre class="code prettyprint linenums">
                        /**!
                         * Sortable
                         * @author	RubaXa   &lt;trash@rubaxa.org&gt;
                         * @license MIT
                         */
                        (function (factory) {
                        	&quot;use strict&quot;;

                        	if (typeof define === &quot;function&quot; &amp;&amp; define.amd) {
                        		define(factory);
                        	}
                        	else if (typeof module != &quot;undefined&quot; &amp;&amp; typeof module.exports != &quot;undefined&quot;) {
                        		module.exports = factory();
                        	}
                        	else if (typeof Package !== &quot;undefined&quot;) {
                        		Sortable = factory();  // export for Meteor.js
                        	}
                        	else {
                        		/* jshint sub:true */
                        		window[&quot;Sortable&quot;] = factory();
                        	}
                        })(function () {
                        	&quot;use strict&quot;;

                        	var dragEl,
                        		ghostEl,
                        		cloneEl,
                        		rootEl,
                        		nextEl,

                        		scrollEl,
                        		scrollParentEl,

                        		lastEl,
                        		lastCSS,

                        		oldIndex,
                        		newIndex,

                        		activeGroup,
                        		autoScroll = {},

                        		tapEvt,
                        		touchEvt,

                        		expando = &#x27;Sortable&#x27; + (new Date).getTime(),

                        		win = window,
                        		document = win.document,
                        		parseInt = win.parseInt,

                        		supportDraggable = !!(&#x27;draggable&#x27; in document.createElement(&#x27;div&#x27;)),


                        		_silent = false,

                        		_dispatchEvent = function (rootEl, name, targetEl, fromEl, startIndex, newIndex) {
                        			var evt = document.createEvent(&#x27;Event&#x27;);

                        			evt.initEvent(name, true, true);

                        			evt.item = targetEl || rootEl;
                        			evt.from = fromEl || rootEl;
                        			evt.clone = cloneEl;

                        			evt.oldIndex = startIndex;
                        			evt.newIndex = newIndex;

                        			rootEl.dispatchEvent(evt);
                        		},

                        		_customEvents = &#x27;onAdd onUpdate onRemove onStart onEnd onFilter onSort&#x27;.split(&#x27; &#x27;),

                        		noop = function () {},

                        		abs = Math.abs,
                        		slice = [].slice,

                        		touchDragOverListeners = [],

                        		_autoScroll = _throttle(function (/**Event*/evt, /**Object*/options, /**HTMLElement*/rootEl) {
                        			// Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
                        			if (rootEl &amp;&amp; options.scroll) {
                        				var el,
                        					rect,
                        					sens = options.scrollSensitivity,
                        					speed = options.scrollSpeed,

                        					x = evt.clientX,
                        					y = evt.clientY,

                        					winWidth = window.innerWidth,
                        					winHeight = window.innerHeight,

                        					vx,
                        					vy
                        				;

                        				// Delect scrollEl
                        				if (scrollParentEl !== rootEl) {
                        					scrollEl = options.scroll;
                        					scrollParentEl = rootEl;

                        					if (scrollEl === true) {
                        						scrollEl = rootEl;

                        						do {
                        							if ((scrollEl.offsetWidth &lt; scrollEl.scrollWidth) ||
                        								(scrollEl.offsetHeight &lt; scrollEl.scrollHeight)
                        							) {
                        								break;
                        							}
                        							/* jshint boss:true */
                        						} while (scrollEl = scrollEl.parentNode);
                        					}
                        				}

                        				if (scrollEl) {
                        					el = scrollEl;
                        					rect = scrollEl.getBoundingClientRect();
                        					vx = (abs(rect.right - x) &lt;= sens) - (abs(rect.left - x) &lt;= sens);
                        					vy = (abs(rect.bottom - y) &lt;= sens) - (abs(rect.top - y) &lt;= sens);
                        				}


                        				if (!(vx || vy)) {
                        					vx = (winWidth - x &lt;= sens) - (x &lt;= sens);
                        					vy = (winHeight - y &lt;= sens) - (y &lt;= sens);

                        					/* jshint expr:true */
                        					(vx || vy) &amp;&amp; (el = win);
                        				}


                        				if (autoScroll.vx !== vx || autoScroll.vy !== vy || autoScroll.el !== el) {
                        					autoScroll.el = el;
                        					autoScroll.vx = vx;
                        					autoScroll.vy = vy;

                        					clearInterval(autoScroll.pid);

                        					if (el) {
                        						autoScroll.pid = setInterval(function () {
                        							if (el === win) {
                        								win.scrollTo(win.scrollX + vx * speed, win.scrollY + vy * speed);
                        							} else {
                        								vy &amp;&amp; (el.scrollTop += vy * speed);
                        								vx &amp;&amp; (el.scrollLeft += vx * speed);
                        							}
                        						}, 24);
                        					}
                        				}
                        			}
                        		}, 30)
                        	;



                        	/**
                        	 * @class  Sortable
                        	 * @param  {HTMLElement}  el
                        	 * @param  {Object}       [options]
                        	 */
                        	function Sortable(el, options) {
                        		this.el = el; // root element
                        		this.options = options = (options || {});

                        		// Default options
                        		var defaults = {
                        			group: Math.random(),
                        			sort: true,
                        			disabled: false,
                        			store: null,
                        			handle: null,
                        			scroll: true,
                        			scrollSensitivity: 30,
                        			scrollSpeed: 10,
                        			draggable: /[uo]l/i.test(el.nodeName) ? &#x27;li&#x27; : &#x27;&gt;*&#x27;,
                        			ghostClass: &#x27;sortable-ghost&#x27;,
                        			ignore: &#x27;a, img&#x27;,
                        			filter: null,
                        			animation: 0,
                        			setData: function (dataTransfer, dragEl) {
                        				dataTransfer.setData(&#x27;Text&#x27;, dragEl.textContent);
                        			},
                        			dropBubble: false,
                        			dragoverBubble: false
                        		};


                        		// Set default options
                        		for (var name in defaults) {
                        			!(name in options) &amp;&amp; (options[name] = defaults[name]);
                        		}


                        		var group = options.group;

                        		if (!group || typeof group != &#x27;object&#x27;) {
                        			group = options.group = { name: group };
                        		}


                        		[&#x27;pull&#x27;, &#x27;put&#x27;].forEach(function (key) {
                        			if (!(key in group)) {
                        				group[key] = true;
                        			}
                        		});


                        		// Define events
                        		_customEvents.forEach(function (name) {
                        			options[name] = _bind(this, options[name] || noop);
                        			_on(el, name.substr(2).toLowerCase(), options[name]);
                        		}, this);


                        		// Export options
                        		options.groups = &#x27; &#x27; + group.name + (group.put.join ? &#x27; &#x27; + group.put.join(&#x27; &#x27;) : &#x27;&#x27;) + &#x27; &#x27;;
                        		el[expando] = options;


                        		// Bind all private methods
                        		for (var fn in this) {
                        			if (fn.charAt(0) === &#x27;_&#x27;) {
                        				this[fn] = _bind(this, this[fn]);
                        			}
                        		}


                        		// Bind events
                        		_on(el, &#x27;mousedown&#x27;, this._onTapStart);
                        		_on(el, &#x27;touchstart&#x27;, this._onTapStart);

                        		_on(el, &#x27;dragover&#x27;, this);
                        		_on(el, &#x27;dragenter&#x27;, this);

                        		touchDragOverListeners.push(this._onDragOver);

                        		// Restore sorting
                        		options.store &amp;&amp; this.sort(options.store.get(this));
                        	}


                        	Sortable.prototype = /** @lends Sortable.prototype */ {
                        		constructor: Sortable,


                        		_dragStarted: function () {
                        			if (rootEl &amp;&amp; dragEl) {
                        				// Apply effect
                        				_toggleClass(dragEl, this.options.ghostClass, true);

                        				Sortable.active = this;

                        				// Drag start event
                        				_dispatchEvent(rootEl, &#x27;start&#x27;, dragEl, rootEl, oldIndex);
                        			}
                        		},


                        		_onTapStart: function (/**Event|TouchEvent*/evt) {
                        			var type = evt.type,
                        				touch = evt.touches &amp;&amp; evt.touches[0],
                        				target = (touch || evt).target,
                        				originalTarget = target,
                        				options =  this.options,
                        				el = this.el,
                        				filter = options.filter;

                        			if (type === &#x27;mousedown&#x27; &amp;&amp; evt.button !== 0 || options.disabled) {
                        				return; // only left button or enabled
                        			}

                        			target = _closest(target, options.draggable, el);

                        			if (!target) {
                        				return;
                        			}

                        			// get the index of the dragged element within its parent
                        			oldIndex = _index(target);

                        			// Check filter
                        			if (typeof filter === &#x27;function&#x27;) {
                        				if (filter.call(this, evt, target, this)) {
                        					_dispatchEvent(originalTarget, &#x27;filter&#x27;, target, el, oldIndex);
                        					evt.preventDefault();
                        					return; // cancel dnd
                        				}
                        			}
                        			else if (filter) {
                        				filter = filter.split(&#x27;,&#x27;).some(function (criteria) {
                        					criteria = _closest(originalTarget, criteria.trim(), el);

                        					if (criteria) {
                        						_dispatchEvent(criteria, &#x27;filter&#x27;, target, el, oldIndex);
                        						return true;
                        					}
                        				});

                        				if (filter) {
                        					evt.preventDefault();
                        					return; // cancel dnd
                        				}
                        			}


                        			if (options.handle &amp;&amp; !_closest(originalTarget, options.handle, el)) {
                        				return;
                        			}


                        			// Prepare &#x60;dragstart&#x60;
                        			if (target &amp;&amp; !dragEl &amp;&amp; (target.parentNode === el)) {
                        				tapEvt = evt;

                        				rootEl = this.el;
                        				dragEl = target;
                        				nextEl = dragEl.nextSibling;
                        				activeGroup = this.options.group;

                        				dragEl.draggable = true;

                        				// Disable &quot;draggable&quot;
                        				options.ignore.split(&#x27;,&#x27;).forEach(function (criteria) {
                        					_find(target, criteria.trim(), _disableDraggable);
                        				});

                        				if (touch) {
                        					// Touch device support
                        					tapEvt = {
                        						target: target,
                        						clientX: touch.clientX,
                        						clientY: touch.clientY
                        					};

                        					this._onDragStart(tapEvt, &#x27;touch&#x27;);
                        					evt.preventDefault();
                        				}

                        				_on(document, &#x27;mouseup&#x27;, this._onDrop);
                        				_on(document, &#x27;touchend&#x27;, this._onDrop);
                        				_on(document, &#x27;touchcancel&#x27;, this._onDrop);

                        				_on(dragEl, &#x27;dragend&#x27;, this);
                        				_on(rootEl, &#x27;dragstart&#x27;, this._onDragStart);

                        				if (!supportDraggable) {
                        					this._onDragStart(tapEvt, true);
                        				}

                        				try {
                        					if (document.selection) {
                        						document.selection.empty();
                        					} else {
                        						window.getSelection().removeAllRanges();
                        					}
                        				} catch (err) {
                        				}
                        			}
                        		},

                        		_emulateDragOver: function () {
                        			if (touchEvt) {
                        				_css(ghostEl, &#x27;display&#x27;, &#x27;none&#x27;);

                        				var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY),
                        					parent = target,
                        					groupName = &#x27; &#x27; + this.options.group.name + &#x27;&#x27;,
                        					i = touchDragOverListeners.length;

                        				if (parent) {
                        					do {
                        						if (parent[expando] &amp;&amp; parent[expando].groups.indexOf(groupName) &gt; -1) {
                        							while (i--) {
                        								touchDragOverListeners[i]({
                        									clientX: touchEvt.clientX,
                        									clientY: touchEvt.clientY,
                        									target: target,
                        									rootEl: parent
                        								});
                        							}

                        							break;
                        						}

                        						target = parent; // store last element
                        					}
                        					/* jshint boss:true */
                        					while (parent = parent.parentNode);
                        				}

                        				_css(ghostEl, &#x27;display&#x27;, &#x27;&#x27;);
                        			}
                        		},


                        		_onTouchMove: function (/**TouchEvent*/evt) {
                        			if (tapEvt) {
                        				var touch = evt.touches ? evt.touches[0] : evt,
                        					dx = touch.clientX - tapEvt.clientX,
                        					dy = touch.clientY - tapEvt.clientY,
                        					translate3d = evt.touches ? &#x27;translate3d(&#x27; + dx + &#x27;px,&#x27; + dy + &#x27;px,0)&#x27; : &#x27;translate(&#x27; + dx + &#x27;px,&#x27; + dy + &#x27;px)&#x27;;

                        				touchEvt = touch;

                        				_css(ghostEl, &#x27;webkitTransform&#x27;, translate3d);
                        				_css(ghostEl, &#x27;mozTransform&#x27;, translate3d);
                        				_css(ghostEl, &#x27;msTransform&#x27;, translate3d);
                        				_css(ghostEl, &#x27;transform&#x27;, translate3d);

                        				evt.preventDefault();
                        			}
                        		},


                        		_onDragStart: function (/**Event*/evt, /**boolean*/useFallback) {
                        			var dataTransfer = evt.dataTransfer,
                        				options = this.options;

                        			this._offUpEvents();

                        			if (activeGroup.pull == &#x27;clone&#x27;) {
                        				cloneEl = dragEl.cloneNode(true);
                        				_css(cloneEl, &#x27;display&#x27;, &#x27;none&#x27;);
                        				rootEl.insertBefore(cloneEl, dragEl);
                        			}

                        			if (useFallback) {
                        				var rect = dragEl.getBoundingClientRect(),
                        					css = _css(dragEl),
                        					ghostRect;

                        				ghostEl = dragEl.cloneNode(true);

                        				_css(ghostEl, &#x27;top&#x27;, rect.top - parseInt(css.marginTop, 10));
                        				_css(ghostEl, &#x27;left&#x27;, rect.left - parseInt(css.marginLeft, 10));
                        				_css(ghostEl, &#x27;width&#x27;, rect.width);
                        				_css(ghostEl, &#x27;height&#x27;, rect.height);
                        				_css(ghostEl, &#x27;opacity&#x27;, &#x27;0.8&#x27;);
                        				_css(ghostEl, &#x27;position&#x27;, &#x27;fixed&#x27;);
                        				_css(ghostEl, &#x27;zIndex&#x27;, &#x27;100000&#x27;);

                        				rootEl.appendChild(ghostEl);

                        				// Fixing dimensions.
                        				ghostRect = ghostEl.getBoundingClientRect();
                        				_css(ghostEl, &#x27;width&#x27;, rect.width * 2 - ghostRect.width);
                        				_css(ghostEl, &#x27;height&#x27;, rect.height * 2 - ghostRect.height);

                        				if (useFallback === &#x27;touch&#x27;) {
                        					// Bind touch events
                        					_on(document, &#x27;touchmove&#x27;, this._onTouchMove);
                        					_on(document, &#x27;touchend&#x27;, this._onDrop);
                        					_on(document, &#x27;touchcancel&#x27;, this._onDrop);
                        				} else {
                        					// Old brwoser
                        					_on(document, &#x27;mousemove&#x27;, this._onTouchMove);
                        					_on(document, &#x27;mouseup&#x27;, this._onDrop);
                        				}

                        				this._loopId = setInterval(this._emulateDragOver, 150);
                        			}
                        			else {
                        				if (dataTransfer) {
                        					dataTransfer.effectAllowed = &#x27;move&#x27;;
                        					options.setData &amp;&amp; options.setData.call(this, dataTransfer, dragEl);
                        				}

                        				_on(document, &#x27;drop&#x27;, this);
                        			}

                        			setTimeout(this._dragStarted, 0);
                        		},

                        		_onDragOver: function (/**Event*/evt) {
                        			var el = this.el,
                        				target,
                        				dragRect,
                        				revert,
                        				options = this.options,
                        				group = options.group,
                        				groupPut = group.put,
                        				isOwner = (activeGroup === group),
                        				canSort = options.sort;

                        			if (!dragEl) {
                        				return;
                        			}

                        			if (evt.preventDefault !== void 0) {
                        				evt.preventDefault();
                        				!options.dragoverBubble &amp;&amp; evt.stopPropagation();
                        			}

                        			if (activeGroup &amp;&amp; !options.disabled &amp;&amp;
                        				(isOwner
                        					? canSort || (revert = !rootEl.contains(dragEl))
                        					: activeGroup.pull &amp;&amp; groupPut &amp;&amp; (
                        						(activeGroup.name === group.name) || // by Name
                        						(groupPut.indexOf &amp;&amp; ~groupPut.indexOf(activeGroup.name)) // by Array
                        					)
                        				) &amp;&amp;
                        				(evt.rootEl === void 0 || evt.rootEl === this.el)
                        			) {
                        				// Smart auto-scrolling
                        				_autoScroll(evt, options, this.el);

                        				if (_silent) {
                        					return;
                        				}

                        				target = _closest(evt.target, options.draggable, el);
                        				dragRect = dragEl.getBoundingClientRect();


                        				if (revert) {
                        					_cloneHide(true);

                        					if (cloneEl || nextEl) {
                        						rootEl.insertBefore(dragEl, cloneEl || nextEl);
                        					}
                        					else if (!canSort) {
                        						rootEl.appendChild(dragEl);
                        					}

                        					return;
                        				}


                        				if ((el.children.length === 0) || (el.children[0] === ghostEl) ||
                        					(el === evt.target) &amp;&amp; (target = _ghostInBottom(el, evt))
                        				) {
                        					if (target) {
                        						if (target.animated) {
                        							return;
                        						}
                        						targetRect = target.getBoundingClientRect();
                        					}

                        					_cloneHide(isOwner);

                        					el.appendChild(dragEl);
                        					this._animate(dragRect, dragEl);
                        					target &amp;&amp; this._animate(targetRect, target);
                        				}
                        				else if (target &amp;&amp; !target.animated &amp;&amp; target !== dragEl &amp;&amp; (target.parentNode[expando] !== void 0)) {
                        					if (lastEl !== target) {
                        						lastEl = target;
                        						lastCSS = _css(target);
                        					}


                        					var targetRect = target.getBoundingClientRect(),
                        						width = targetRect.right - targetRect.left,
                        						height = targetRect.bottom - targetRect.top,
                        						floating = /left|right|inline/.test(lastCSS.cssFloat + lastCSS.display),
                        						isWide = (target.offsetWidth &gt; dragEl.offsetWidth),
                        						isLong = (target.offsetHeight &gt; dragEl.offsetHeight),
                        						halfway = (floating ? (evt.clientX - targetRect.left) / width : (evt.clientY - targetRect.top) / height) &gt; 0.5,
                        						nextSibling = target.nextElementSibling,
                        						after
                        					;

                        					_silent = true;
                        					setTimeout(_unsilent, 30);

                        					_cloneHide(isOwner);

                        					if (floating) {
                        						after = (target.previousElementSibling === dragEl) &amp;&amp; !isWide || halfway &amp;&amp; isWide;
                        					} else {
                        						after = (nextSibling !== dragEl) &amp;&amp; !isLong || halfway &amp;&amp; isLong;
                        					}

                        					if (after &amp;&amp; !nextSibling) {
                        						el.appendChild(dragEl);
                        					} else {
                        						target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
                        					}

                        					this._animate(dragRect, dragEl);
                        					this._animate(targetRect, target);
                        				}
                        			}
                        		},

                        		_animate: function (prevRect, target) {
                        			var ms = this.options.animation;

                        			if (ms) {
                        				var currentRect = target.getBoundingClientRect();

                        				_css(target, &#x27;transition&#x27;, &#x27;none&#x27;);
                        				_css(target, &#x27;transform&#x27;, &#x27;translate3d(&#x27;
                        					+ (prevRect.left - currentRect.left) + &#x27;px,&#x27;
                        					+ (prevRect.top - currentRect.top) + &#x27;px,0)&#x27;
                        				);

                        				target.offsetWidth; // repaint

                        				_css(target, &#x27;transition&#x27;, &#x27;all &#x27; + ms + &#x27;ms&#x27;);
                        				_css(target, &#x27;transform&#x27;, &#x27;translate3d(0,0,0)&#x27;);

                        				clearTimeout(target.animated);
                        				target.animated = setTimeout(function () {
                        					_css(target, &#x27;transition&#x27;, &#x27;&#x27;);
                        					_css(target, &#x27;transform&#x27;, &#x27;&#x27;);
                        					target.animated = false;
                        				}, ms);
                        			}
                        		},

                        		_offUpEvents: function () {
                        			_off(document, &#x27;mouseup&#x27;, this._onDrop);
                        			_off(document, &#x27;touchmove&#x27;, this._onTouchMove);
                        			_off(document, &#x27;touchend&#x27;, this._onDrop);
                        			_off(document, &#x27;touchcancel&#x27;, this._onDrop);
                        		},

                        		_onDrop: function (/**Event*/evt) {
                        			var el = this.el,
                        				options = this.options;

                        			clearInterval(this._loopId);
                        			clearInterval(autoScroll.pid);

                        			// Unbind events
                        			_off(document, &#x27;drop&#x27;, this);
                        			_off(document, &#x27;mousemove&#x27;, this._onTouchMove);
                        			_off(el, &#x27;dragstart&#x27;, this._onDragStart);

                        			this._offUpEvents();

                        			if (evt) {
                        				evt.preventDefault();
                        				!options.dropBubble &amp;&amp; evt.stopPropagation();

                        				ghostEl &amp;&amp; ghostEl.parentNode.removeChild(ghostEl);

                        				if (dragEl) {
                        					_off(dragEl, &#x27;dragend&#x27;, this);

                        					_disableDraggable(dragEl);
                        					_toggleClass(dragEl, this.options.ghostClass, false);

                        					if (rootEl !== dragEl.parentNode) {
                        						newIndex = _index(dragEl);

                        						// drag from one list and drop into another
                        						_dispatchEvent(dragEl.parentNode, &#x27;sort&#x27;, dragEl, rootEl, oldIndex, newIndex);
                        						_dispatchEvent(rootEl, &#x27;sort&#x27;, dragEl, rootEl, oldIndex, newIndex);

                        						// Add event
                        						_dispatchEvent(dragEl, &#x27;add&#x27;, dragEl, rootEl, oldIndex, newIndex);

                        						// Remove event
                        						_dispatchEvent(rootEl, &#x27;remove&#x27;, dragEl, rootEl, oldIndex, newIndex);
                        					}
                        					else {
                        						// Remove clone
                        						cloneEl &amp;&amp; cloneEl.parentNode.removeChild(cloneEl);

                        						if (dragEl.nextSibling !== nextEl) {
                        							// Get the index of the dragged element within its parent
                        							newIndex = _index(dragEl);

                        							// drag &amp; drop within the same list
                        							_dispatchEvent(rootEl, &#x27;update&#x27;, dragEl, rootEl, oldIndex, newIndex);
                        							_dispatchEvent(rootEl, &#x27;sort&#x27;, dragEl, rootEl, oldIndex, newIndex);
                        						}
                        					}

                        					// Drag end event
                        					Sortable.active &amp;&amp; _dispatchEvent(rootEl, &#x27;end&#x27;, dragEl, rootEl, oldIndex, newIndex);
                        				}

                        				// Nulling
                        				rootEl =
                        				dragEl =
                        				ghostEl =
                        				nextEl =
                        				cloneEl =

                        				scrollEl =
                        				scrollParentEl =

                        				tapEvt =
                        				touchEvt =

                        				lastEl =
                        				lastCSS =

                        				activeGroup =
                        				Sortable.active = null;

                        				// Save sorting
                        				this.save();
                        			}
                        		},


                        		handleEvent: function (/**Event*/evt) {
                        			var type = evt.type;

                        			if (type === &#x27;dragover&#x27; || type === &#x27;dragenter&#x27;) {
                        				this._onDragOver(evt);
                        				_globalDragOver(evt);
                        			}
                        			else if (type === &#x27;drop&#x27; || type === &#x27;dragend&#x27;) {
                        				this._onDrop(evt);
                        			}
                        		},


                        		/**
                        		 * Serializes the item into an array of string.
                        		 * @returns {String[]}
                        		 */
                        		toArray: function () {
                        			var order = [],
                        				el,
                        				children = this.el.children,
                        				i = 0,
                        				n = children.length;

                        			for (; i &lt; n; i++) {
                        				el = children[i];
                        				if (_closest(el, this.options.draggable, this.el)) {
                        					order.push(el.getAttribute(&#x27;data-id&#x27;) || _generateId(el));
                        				}
                        			}

                        			return order;
                        		},


                        		/**
                        		 * Sorts the elements according to the array.
                        		 * @param  {String[]}  order  order of the items
                        		 */
                        		sort: function (order) {
                        			var items = {}, rootEl = this.el;

                        			this.toArray().forEach(function (id, i) {
                        				var el = rootEl.children[i];

                        				if (_closest(el, this.options.draggable, rootEl)) {
                        					items[id] = el;
                        				}
                        			}, this);

                        			order.forEach(function (id) {
                        				if (items[id]) {
                        					rootEl.removeChild(items[id]);
                        					rootEl.appendChild(items[id]);
                        				}
                        			});
                        		},


                        		/**
                        		 * Save the current sorting
                        		 */
                        		save: function () {
                        			var store = this.options.store;
                        			store &amp;&amp; store.set(this);
                        		},


                        		/**
                        		 * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
                        		 * @param   {HTMLElement}  el
                        		 * @param   {String}       [selector]  default: &#x60;options.draggable&#x60;
                        		 * @returns {HTMLElement|null}
                        		 */
                        		closest: function (el, selector) {
                        			return _closest(el, selector || this.options.draggable, this.el);
                        		},


                        		/**
                        		 * Set/get option
                        		 * @param   {string} name
                        		 * @param   {*}      [value]
                        		 * @returns {*}
                        		 */
                        		option: function (name, value) {
                        			var options = this.options;

                        			if (value === void 0) {
                        				return options[name];
                        			} else {
                        				options[name] = value;
                        			}
                        		},


                        		/**
                        		 * Destroy
                        		 */
                        		destroy: function () {
                        			var el = this.el, options = this.options;

                        			_customEvents.forEach(function (name) {
                        				_off(el, name.substr(2).toLowerCase(), options[name]);
                        			});

                        			_off(el, &#x27;mousedown&#x27;, this._onTapStart);
                        			_off(el, &#x27;touchstart&#x27;, this._onTapStart);

                        			_off(el, &#x27;dragover&#x27;, this);
                        			_off(el, &#x27;dragenter&#x27;, this);

                        			//remove draggable attributes
                        			Array.prototype.forEach.call(el.querySelectorAll(&#x27;[draggable]&#x27;), function (el) {
                        				el.removeAttribute(&#x27;draggable&#x27;);
                        			});

                        			touchDragOverListeners.splice(touchDragOverListeners.indexOf(this._onDragOver), 1);

                        			this._onDrop();

                        			this.el = null;
                        		}
                        	};


                        	function _cloneHide(state) {
                        		if (cloneEl &amp;&amp; (cloneEl.state !== state)) {
                        			_css(cloneEl, &#x27;display&#x27;, state ? &#x27;none&#x27; : &#x27;&#x27;);
                        			!state &amp;&amp; cloneEl.state &amp;&amp; rootEl.insertBefore(cloneEl, dragEl);
                        			cloneEl.state = state;
                        		}
                        	}


                        	function _bind(ctx, fn) {
                        		var args = slice.call(arguments, 2);
                        		return	fn.bind ? fn.bind.apply(fn, [ctx].concat(args)) : function () {
                        			return fn.apply(ctx, args.concat(slice.call(arguments)));
                        		};
                        	}


                        	function _closest(/**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx) {
                        		if (el) {
                        			ctx = ctx || document;
                        			selector = selector.split(&#x27;.&#x27;);

                        			var tag = selector.shift().toUpperCase(),
                        				re = new RegExp(&#x27;\\s(&#x27; + selector.join(&#x27;|&#x27;) + &#x27;)\\s&#x27;, &#x27;g&#x27;);

                        			do {
                        				if (
                        					(tag === &#x27;&gt;*&#x27; &amp;&amp; el.parentNode === ctx) || (
                        						(tag === &#x27;&#x27; || el.nodeName.toUpperCase() == tag) &amp;&amp;
                        						(!selector.length || ((&#x27; &#x27; + el.className + &#x27; &#x27;).match(re) || []).length == selector.length)
                        					)
                        				) {
                        					return el;
                        				}
                        			}
                        			while (el !== ctx &amp;&amp; (el = el.parentNode));
                        		}

                        		return null;
                        	}


                        	function _globalDragOver(/**Event*/evt) {
                        		evt.dataTransfer.dropEffect = &#x27;move&#x27;;
                        		evt.preventDefault();
                        	}


                        	function _on(el, event, fn) {
                        		el.addEventListener(event, fn, false);
                        	}


                        	function _off(el, event, fn) {
                        		el.removeEventListener(event, fn, false);
                        	}


                        	function _toggleClass(el, name, state) {
                        		if (el) {
                        			if (el.classList) {
                        				el.classList[state ? &#x27;add&#x27; : &#x27;remove&#x27;](name);
                        			}
                        			else {
                        				var className = (&#x27; &#x27; + el.className + &#x27; &#x27;).replace(/\s+/g, &#x27; &#x27;).replace(&#x27; &#x27; + name + &#x27; &#x27;, &#x27;&#x27;);
                        				el.className = className + (state ? &#x27; &#x27; + name : &#x27;&#x27;);
                        			}
                        		}
                        	}


                        	function _css(el, prop, val) {
                        		var style = el &amp;&amp; el.style;

                        		if (style) {
                        			if (val === void 0) {
                        				if (document.defaultView &amp;&amp; document.defaultView.getComputedStyle) {
                        					val = document.defaultView.getComputedStyle(el, &#x27;&#x27;);
                        				}
                        				else if (el.currentStyle) {
                        					val = el.currentStyle;
                        				}

                        				return prop === void 0 ? val : val[prop];
                        			}
                        			else {
                        				if (!(prop in style)) {
                        					prop = &#x27;-webkit-&#x27; + prop;
                        				}

                        				style[prop] = val + (typeof val === &#x27;string&#x27; ? &#x27;&#x27; : &#x27;px&#x27;);
                        			}
                        		}
                        	}


                        	function _find(ctx, tagName, iterator) {
                        		if (ctx) {
                        			var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;

                        			if (iterator) {
                        				for (; i &lt; n; i++) {
                        					iterator(list[i], i);
                        				}
                        			}

                        			return list;
                        		}

                        		return [];
                        	}


                        	function _disableDraggable(el) {
                        		el.draggable = false;
                        	}


                        	function _unsilent() {
                        		_silent = false;
                        	}


                        	/** @returns {HTMLElement|false} */
                        	function _ghostInBottom(el, evt) {
                        		var lastEl = el.lastElementChild, rect = lastEl.getBoundingClientRect();
                        		return (evt.clientY - (rect.top + rect.height) &gt; 5) &amp;&amp; lastEl; // min delta
                        	}


                        	/**
                        	 * Generate id
                        	 * @param   {HTMLElement} el
                        	 * @returns {String}
                        	 * @private
                        	 */
                        	function _generateId(el) {
                        		var str = el.tagName + el.className + el.src + el.href + el.textContent,
                        			i = str.length,
                        			sum = 0;

                        		while (i--) {
                        			sum += str.charCodeAt(i);
                        		}

                        		return sum.toString(36);
                        	}

                        	/**
                        	 * Returns the index of an element within its parent
                        	 * @param el
                        	 * @returns {number}
                        	 * @private
                        	 */
                        	function _index(/**HTMLElement*/el) {
                        		var index = 0;
                        		while (el &amp;&amp; (el = el.previousElementSibling)) {
                        			if (el.nodeName.toUpperCase() !== &#x27;TEMPLATE&#x27;) {
                        				index++;
                        			}
                        		}
                        		return index;
                        	}

                        	function _throttle(callback, ms) {
                        		var args, _this;

                        		return function () {
                        			if (args === void 0) {
                        				args = arguments;
                        				_this = this;

                        				setTimeout(function () {
                        					if (args.length === 1) {
                        						callback.call(_this, args[0]);
                        					} else {
                        						callback.apply(_this, args);
                        					}

                        					args = void 0;
                        				}, ms);
                        			}
                        		};
                        	}


                        	// Export utils
                        	Sortable.utils = {
                        		on: _on,
                        		off: _off,
                        		css: _css,
                        		find: _find,
                        		bind: _bind,
                        		is: function (el, selector) {
                        			return !!_closest(el, selector, el);
                        		},
                        		throttle: _throttle,
                        		closest: _closest,
                        		toggleClass: _toggleClass,
                        		dispatchEvent: _dispatchEvent,
                        		index: _index
                        	};


                        	Sortable.version = &#x27;1.1.1&#x27;;


                        	/**
                        	 * Create sortable instance
                        	 * @param {HTMLElement}  el
                        	 * @param {Object}      [options]
                        	 */
                        	Sortable.create = function (el, options) {
                        		return new Sortable(el, options);
                        	};

                        	// Export
                        	return Sortable;
                        });

                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
